<html>
    <head>
        <title>nlog(m)</title>
        <link href="https://micro.blog/mtoth" rel="me" />
    </head>
    <body style="font-family: sans-serif; max-width: 900px; margin: auto; margin-top: 30px;font-size: 16px;line-height: 30px;">
        <!--
        <div>
            <p>
                Placeholder for github-style activity chart
            </p>
        </div>
        <hr/>
        -->
        <div>
            <h1>
                Index
            </h1>
            <ul>
                <li><a href="#gitrevparse">Understanding git rev-parse 9/7/2018</a></li>
                <li><a href="#localcache">WIP: Even more local cache 11/26/2018</a></li>
                <li><a href="#rtl-ltr">WIP: Working with RTL characters 12/10/2018</a></li>
                <!--<li><a href="about.html">About</a></li>-->
            </ul>
        </div>

        <!-- POST TEMPLATE
        <div style="display:none"> // remove when ready to show
        <hr/> // divides posts
          <input type="checkbox" style="display:none" /> // used to jump to section of page
          <div id="hidden"> // same as above
          <h1><a id="localcache">TITLE</a></h1>
          <p>
            LOTS OF TEXT
          </p>
        </div>
        </div>

        -->

        <!-- POST -->
        <div style="display:none">
        <hr/>
          <input type="checkbox" style="display:none" />
          <div id="hidden">
          <h1><a id="localcache">Hyper Local</a></h1>
          <p>
            An even more local cache than localStorage. And why localStorage is such a bad name. And other stuff.
            Localstorage is a terrible name because it is too developer centric -- a user will never and probably should never touch their localStorage.
            But thats the best we have in terms of "local" control over data. The more local your application is, the more you are empowering you users.
            All of this is a digression from the specific thing I am writing about
          </p>
        </div>
        </div>

        <!-- POST -->
        <div>
            <hr/>
            <p style="text-align: center">
                <input type="checkbox" style="display:none" />
                <div id="hidden">
                    <h1><a id="gitrevparse">Understanding git rev-parse</a></h1>

                    <p>
                        Working on a pre-commit hook for git and was trying to figure out what
                    <pre style="
                            background: #f4f4f4;
                            border: 1px solid #ddd;
                            color: #666;
                            page-break-inside: avoid;
                            font-family: monospace;
                            font-size: 15px;
                            margin-bottom: 1.6em;
                            max-width: 100%;
                            overflow: auto;
                            display: block;
                            line-height: 20px;
                            word-wrap: break-word;">
                        <code>
                        if git rev-parse --verify HEAD >/dev/null 2>&1
                        then
                            against=HEAD
                        else
                            # Initial commit: diff against an empty tree object
                            against=4b825dc642cb6eb9a060e54bf8d69288fbee4904
                        fi
                        </code>
                    </pre>
                        did. 
                    </p>

                    <p>
                        So <code style="font-size: 15px; background: #f4f4f4;">git rev-parse</code> is a plumbing command that tries to help users understand the maze of parameters that are passed by normal porcelin commands <code style="font-size: 15px; background: #f4f4f4;">git log</code> to the plumbing command <code style="font-size: 15px; background: #f4f4f4;">git rev-list</code> which lists git commit objects. Using <code style="font-size: 15px; background: #f4f4f4;">git rev-list</code> reminds me why its a plumbing command. Its output and <code style="font-size: 15px; background: #f4f4f4;">man</code> entry are hard to read at best. <code style="font-size: 15px; background: #f4f4f4;">git rev-parse --verify HEAD</code> is the most user-friendly way to display what commit hash HEAD is currently pointing to.

                    </p>
                    <p>
                    But why is that useful? Its also a useful way to tell if a git repository is empty (just initialized) or not. And thats why the SHA <code style="font-size: 15px; background: #f4f4f4;">4b825dc642cb6eb9a060e54bf8d69288fbee4904</code> is so special. It is the representation of an empty git tree object. Its the same across every project; <b>so if you start a new git repo and enable pre-commit hooks against your very first commit, this if-block will make sure your commit is diffed against the correct object.</b> Either the HEAD or if there are no other commits in the project, an empty tree object. 
                    </p>
                </p>
            </div>
        </div>
    </body>
</html>
